<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hand Gesture Control with Physics</title>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
  <script src="https://cdn.babylonjs.com/ammo.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; overflow: hidden; }
    #video-container {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 320px;
      height: 240px;
      z-index: 10;
      border: 2px solid white;
      border-radius: 8px;
      overflow: hidden;
      transform: scaleX(-1);
    }
    #video, #canvas {
      width: 100%;
      height: 100%;
    }
    #renderCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      touch-action: none;
    }
    .container { 
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    .gesture-info { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 10px; 
      border-radius: 5px;
      z-index: 20;
    }
    .coordinates {
      position: absolute;
      top: 10px;
      right: 350px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 20;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 20;
    }
    .controls button {
      margin: 5px;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #clear-btn { background: #ff4444; color: white; }
    #clear-btn:hover { background: #ff0000; }
    #create-box { background: #44ff44; color: black; }
    #create-sphere { background: #4444ff; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Babylon.js Canvas (fullscreen background) -->
    <canvas id="renderCanvas"></canvas>
    
    <!-- MediaPipe Overlay (small preview in corner) -->
    <div id="video-container">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>
    
    <!-- UI Elements -->
    <div id="gesture-info" class="gesture-info"></div>
    <div id="coordinates" class="coordinates">Coordinates will appear here</div>
    <div class="controls">
      <button id="clear-btn">Clear Scene</button>
      <button id="create-box">Create Box</button>
      <button id="create-sphere">Create Sphere</button>
    </div>
  </div>

  <script>
    // ========== MediaPipe Hand Tracking ==========
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gestureInfo = document.getElementById('gesture-info');
    const coordinatesDisplay = document.getElementById('coordinates');
    const clearBtn = document.getElementById('clear-btn');
    const createBoxBtn = document.getElementById('create-box');
    const createSphereBtn = document.getElementById('create-sphere');

    // Initialize MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    // ========== Babylon.js 3D Scene ==========
    const renderCanvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(renderCanvas, true);
    
    const createScene = async function() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
      
      // Camera
      const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2, 15, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(renderCanvas, true);
      camera.lowerRadiusLimit = 5;
      camera.upperRadiusLimit = 30;
      
      // Light
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 0.7;

      // Initialize physics
      await Ammo();
      scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin());
      
      // Create a large ground box (lebih besar untuk pembatas)
      const ground = BABYLON.MeshBuilder.CreateBox("ground", { width: 20, depth: 20, height: 1 }, scene);
      ground.position.y = -0.5;

      // Create circular holes di pojok-pojok
      const hole1 = BABYLON.MeshBuilder.CreateCylinder("hole1", { diameter: 2, height: 2 }, scene);
      hole1.position.y = -0.5;
      hole1.position.x = -8;
      hole1.position.z = -8;

      const hole2 = BABYLON.MeshBuilder.CreateCylinder("hole2", { diameter: 2, height: 2 }, scene);
      hole2.position.y = -0.5;
      hole2.position.x = 8;
      hole2.position.z = -8;

      const hole3 = BABYLON.MeshBuilder.CreateCylinder("hole3", { diameter: 2, height: 2 }, scene);
      hole3.position.y = -0.5;
      hole3.position.x = -8;
      hole3.position.z = 8;

      const hole4 = BABYLON.MeshBuilder.CreateCylinder("hole4", { diameter: 2, height: 2 }, scene);
      hole4.position.y = -0.5;
      hole4.position.x = 8;
      hole4.position.z = 8;

      // Create a box to represent the square hole di tengah (ukuran sama dengan cube = 1 unit)
      const squareHole = BABYLON.MeshBuilder.CreateBox("squareHole", { width: 1, depth: 1, height: 2 }, scene);
      squareHole.position.y = -0.5;
      squareHole.position.x = 0; // Position the square hole at center
      squareHole.position.z = 0;

      // Perform CSG subtraction to create holes in the ground
      const groundCSG = BABYLON.CSG.FromMesh(ground);
      const hole1CSG = BABYLON.CSG.FromMesh(hole1);
      const hole2CSG = BABYLON.CSG.FromMesh(hole2);
      const hole3CSG = BABYLON.CSG.FromMesh(hole3);
      const hole4CSG = BABYLON.CSG.FromMesh(hole4);
      const squareHoleCSG = BABYLON.CSG.FromMesh(squareHole);
      
      // Subtract all holes from ground
      let groundWithHolesCSG = groundCSG;
      groundWithHolesCSG = groundWithHolesCSG.subtract(hole1CSG);
      groundWithHolesCSG = groundWithHolesCSG.subtract(hole2CSG);
      groundWithHolesCSG = groundWithHolesCSG.subtract(hole3CSG);
      groundWithHolesCSG = groundWithHolesCSG.subtract(hole4CSG);
      groundWithHolesCSG = groundWithHolesCSG.subtract(squareHoleCSG);
      
      const groundWithHoles = groundWithHolesCSG.toMesh("groundWithHoles", null, scene);

      // Dispose of the original meshes
      ground.dispose();
      hole1.dispose();
      hole2.dispose();
      hole3.dispose();
      hole4.dispose();
      squareHole.dispose();

      // Apply YELLOW material to the new ground
      groundWithHoles.material = new BABYLON.StandardMaterial("groundMat", scene);
      groundWithHoles.material.diffuseColor = new BABYLON.Color3(1, 1, 0); // Warna kuning
      groundWithHoles.material.alpha = 0.8;

      // Assign a physics impostor to the ground
      groundWithHoles.physicsImpostor = new BABYLON.PhysicsImpostor(
        groundWithHoles, 
        BABYLON.PhysicsImpostor.MeshImpostor, 
        { mass: 0, restitution: 0.1, friction: 0.5 }, 
        scene
      );

      // Create boundary walls around the ground
      createBoundaryWalls(scene);
            
      return scene;
    };

    // Function to create boundary walls
    function createBoundaryWalls(scene) {
      const wallHeight = 2;
      const wallThickness = 0.5;
      const groundSize = 20;
      
      // North wall
      const northWall = BABYLON.MeshBuilder.CreateBox("northWall", { 
        width: groundSize + wallThickness, 
        height: wallHeight, 
        depth: wallThickness 
      }, scene);
      northWall.position.z = -groundSize/2 - wallThickness/2;
      northWall.position.y = wallHeight/2 - 0.5;
      
      // South wall
      const southWall = BABYLON.MeshBuilder.CreateBox("southWall", { 
        width: groundSize + wallThickness, 
        height: wallHeight, 
        depth: wallThickness 
      }, scene);
      southWall.position.z = groundSize/2 + wallThickness/2;
      southWall.position.y = wallHeight/2 - 0.5;
      
      // East wall
      const eastWall = BABYLON.MeshBuilder.CreateBox("eastWall", { 
        width: wallThickness, 
        height: wallHeight, 
        depth: groundSize + wallThickness 
      }, scene);
      eastWall.position.x = groundSize/2 + wallThickness/2;
      eastWall.position.y = wallHeight/2 - 0.5;
      
      // West wall
      const westWall = BABYLON.MeshBuilder.CreateBox("westWall", { 
        width: wallThickness, 
        height: wallHeight, 
        depth: groundSize + wallThickness 
      }, scene);
      westWall.position.x = -groundSize/2 - wallThickness/2;
      westWall.position.y = wallHeight/2 - 0.5;
      
      // Apply wall material
      const wallMaterial = new BABYLON.StandardMaterial("wallMat", scene);
      wallMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
      
      northWall.material = wallMaterial;
      southWall.material = wallMaterial;
      eastWall.material = wallMaterial;
      westWall.material = wallMaterial;
      
      // Add physics to walls
      [northWall, southWall, eastWall, westWall].forEach(wall => {
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(
          wall, 
          BABYLON.PhysicsImpostor.BoxImpostor, 
          { mass: 0, restitution: 0.5, friction: 0.3 }, 
          scene
        );
      });
    }

    let scene;
    let meshes = [];
    let controlledObjects = [];  // Array to store all controllable objects
    let lastHandPositions = [null, null];  // Track positions for two hands
    let lastPinchTimes = [0, 0];
    let selectedObjectIndex = 0;  // Currently selected object index

    // Create box function
    function createBox() {
      const box = BABYLON.MeshBuilder.CreateBox("box", {size: 1}, scene);
      box.position.y = 5; // Start above ground
      box.position.z = 2; // Start above ground
      
      box.material = new BABYLON.StandardMaterial("boxMat", scene);
      box.material.diffuseColor = BABYLON.Color3.Random();
      
      // Add physics
      box.physicsImpostor = new BABYLON.PhysicsImpostor(
        box, 
        BABYLON.PhysicsImpostor.BoxImpostor, 
        { mass: 1, restitution: 0.2, friction: 0.5 }, 
        scene
      );
      
      meshes.push(box);
      controlledObjects.push(box);
      updateCoordinates();
    }

    // Create sphere function
    function createSphere() {
      const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1}, scene);
      sphere.position.y = 5; // Start above ground
      sphere.position.x = 2; 
      
      sphere.material = new BABYLON.StandardMaterial("sphereMat", scene);
      sphere.material.diffuseColor = BABYLON.Color3.Random();
      
      // Add physics
      sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
        sphere, 
        BABYLON.PhysicsImpostor.SphereImpostor, 
        { mass: 1, restitution: 0.3, friction: 0.5 }, 
        scene
      );
      
      meshes.push(sphere);
      controlledObjects.push(sphere);
      updateCoordinates();
    }

    // Clear all meshes
    function clearMeshes() {
      meshes.forEach(mesh => mesh.dispose());
      meshes = [];
      controlledObjects = [];
      updateCoordinates();
    }

    // Update coordinates display
    function updateCoordinates() {
      if (controlledObjects.length === 0) {
        coordinatesDisplay.innerHTML = "No objects in scene";
        return;
      }
      
      let coordText = "<strong>Objects Coordinates:</strong><br>";
      controlledObjects.forEach((obj, index) => {
        const highlight = index === selectedObjectIndex ? "color: yellow;" : "";
        coordText += `<span style="${highlight}">Object ${index + 1}: `;
        coordText += `X: ${obj.position.x.toFixed(2)}, `;
        coordText += `Y: ${obj.position.y.toFixed(2)}, `;
        coordText += `Z: ${obj.position.z.toFixed(2)}</span><br>`;
      });
      coordinatesDisplay.innerHTML = coordText;
    }

    // Check if object is over a hole
    function isOverHole(position) {
      const holePositions = [
        // Circular holes di pojok
        new BABYLON.Vector3(-8, 0, -8),
        new BABYLON.Vector3(8, 0, -8),
        new BABYLON.Vector3(-8, 0, 8),
        new BABYLON.Vector3(8, 0, 8),
        // Square hole di tengah
        new BABYLON.Vector3(0, 0, 0)
      ];
      
      const holeRadii = [1, 1, 1, 1, 0.5]; // Radius untuk lubang
      
      for (let i = 0; i < holePositions.length; i++) {
        const distance = BABYLON.Vector3.Distance(
          new BABYLON.Vector3(position.x, 0, position.z),
          holePositions[i]
        );
        if (distance < holeRadii[i]) {
          return true;
        }
      }
      return false;
    }

    // ========== Hand Gesture Functions ==========
    function isPinching(landmarks) {
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];

      const distance = Math.sqrt(
        Math.pow(thumbTip.x - indexTip.x, 2) +
        Math.pow(thumbTip.y - indexTip.y, 2) +
        Math.pow(thumbTip.z - indexTip.z, 2)
      );

      return distance < 0.08;
    }

    function isFist(landmarks) {
      const fingerTips = [8, 12, 16, 20];
      const fingerMCPs = [5, 9, 13, 17];
      
      for (let i = 0; i < fingerTips.length; i++) {
        const tip = landmarks[fingerTips[i]];
        const mcp = landmarks[fingerMCPs[i]];
        if (tip.y < mcp.y) return false;
      }
      return true;
    }

    function isOpenHand(landmarks) {
      const fingerTips = [8, 12, 16, 20];
      const fingerPIPs = [6, 10, 14, 18];
      
      for (let i = 0; i < fingerTips.length; i++) {
        const tip = landmarks[fingerTips[i]];
        const pip = landmarks[fingerPIPs[i]];
        if (tip.y > pip.y) return false;
      }
      return true;
    }

    function isPointing(landmarks) {
      // Check if index finger is extended and others are folded
      const indexTip = landmarks[8];
      const indexDip = landmarks[7];
      const indexPip = landmarks[6];
      
      // Index finger should be extended
      if (indexTip.y > indexDip.y || indexTip.y > indexPip.y) return false;
      
      // Other fingers should be folded
      const otherTips = [12, 16, 20];
      const otherMcps = [9, 13, 17];
      
      for (let i = 0; i < otherTips.length; i++) {
        const tip = landmarks[otherTips[i]];
        const mcp = landmarks[otherMcps[i]];
        if (tip.y < mcp.y) return false;
      }
      
      return true;
    }

    // Process hand tracking results
    hands.onResults((results) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      ctx.restore();

      gestureInfo.innerHTML = '';
      
      if (results.multiHandLandmarks && controlledObjects.length > 0) {
        results.multiHandLandmarks.forEach((landmarks, handIdx) => {
          // Draw landmarks
          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
          drawLandmarks(ctx, landmarks, { color: '#FF0000', radius: 3 });

          // Calculate hand center (normalized 0-1)
          let sumX = 0, sumY = 0;
          landmarks.forEach(lm => {
            sumX += lm.x;
            sumY += lm.y;
          });
          const handX = sumX / landmarks.length;
          const handY = sumY / landmarks.length;

          // Detect gestures
          const gestures = [];
          const pinching = isPinching(landmarks);
          const fist = isFist(landmarks);
          const openHand = isOpenHand(landmarks);
          const pointing = isPointing(landmarks);
          
          if (pinching) gestures.push("PINCHING");
          if (fist) gestures.push("FIST");
          if (openHand) gestures.push("OPEN HAND");
          if (pointing) gestures.push("POINTING");
          
          // Display gesture info
          gestureInfo.innerHTML += `Hand ${handIdx + 1}: ${gestures.join(", ") || "No gesture"}<br>`;
          
          // Get video container position
          const container = document.getElementById('video-container');
          const rect = container.getBoundingClientRect();
          
          // Map hand position to 3D scene coordinates (sesuai dengan ukuran ground yang baru)
          const sceneX = (handX * rect.width / rect.width) * 20 - 10;
          const sceneZ = (handY * rect.height / rect.height) * 20 - 10;
          
          // Select object with pointing gesture (only for first hand)
          if (pointing && handIdx === 0) {
            // Cycle through objects
            selectedObjectIndex = (selectedObjectIndex + 1) % controlledObjects.length;
            updateCoordinates();
          }
          
          // Control the selected object
          const controlledObj = controlledObjects[selectedObjectIndex];
          
          if (pinching && controlledObj) {
            // Freeze physics while moving
            controlledObj.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            controlledObj.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
            
            // Move object to hand position
            controlledObj.position.x = -sceneX;
            controlledObj.position.z = -sceneZ;
            
            // Reset Y position if not over a hole
            if (!isOverHole(controlledObj.position)) {
              controlledObj.position.y = 0.5;
            }
            
            // Double pinch to change color
            const now = Date.now();
            if (now - lastPinchTimes[handIdx] < 500) {
              controlledObj.material.diffuseColor = BABYLON.Color3.Random();
            }
            lastPinchTimes[handIdx] = now;
          }
          
          if (fist && controlledObj) {
            // Rotate based on horizontal movement
            controlledObj.rotation.y += (handX - 0.5) * 0.1;
          }
          
          if (openHand && lastHandPositions[handIdx] && controlledObj) {
            // Move forward/backward (Z-axis) based on vertical movement
            const deltaY = handY - lastHandPositions[handIdx].y;
            controlledObj.position.z += deltaY * 2;
            
            // Check if over hole after movement
            if (isOverHole(controlledObj.position)) {
              // If over hole, let physics take over
              controlledObj.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, -5, 0));
            }
          }
          
          lastHandPositions[handIdx] = { x: handX, y: handY };
        });
        
        updateCoordinates();
      }
    });

    // ========== Start Everything ==========
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 320, height: 240, facingMode: 'user' } 
        });
        video.srcObject = stream;
        
        await new Promise((resolve) => {
          video.onloadedmetadata = resolve;
        });

        const camera = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240
        });
        camera.start();
      } catch (err) {
        console.error("Camera error:", err);
      }
    }

    // UI Event Listeners
    clearBtn.addEventListener('click', clearMeshes);
    createBoxBtn.addEventListener('click', createBox);
    createSphereBtn.addEventListener('click', createSphere);

    // Initialize scene and run the render loop
    (async () => {
      scene = await createScene();
      
      // Run the render loop
      engine.runRenderLoop(() => scene.render());
      window.addEventListener('resize', () => engine.resize());

      await hands.initialize();
      startCamera();
      
      // Create initial objects
      createSphere();
      createBox();
    })();
  </script>
</body>
</html>